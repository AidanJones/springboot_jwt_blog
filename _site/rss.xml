<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Auth0 Blog</title>
    <link>https://auth0.com/blog/</link>
    <atom:link href="https://auth0.com/blog/rss.xml" rel="self" type="application/rss+xml" />
    <description>Auth0 Blog</description>
    <language>en-us</language>
    <pubDate>Wed, 06 May 2015 16:17:44 -0300</pubDate>
    <lastBuildDate>Wed, 06 May 2015 16:17:44 -0300</lastBuildDate>

    
      
        <item>
          <title>Engineering the Design Process at Auth0</title>
          <link>https://auth0.com/blog/2015/05/04/design-at-auth0/</link>
          <pubDate>Mon, 04 May 2015 13:24:00 -0300</pubDate>
          <author>Ricky Rauch</author>
          <avatar>https://www.gravatar.com/avatar/27396b3fa24389198ef5d3e7e410e9c4?size=60</avatar>
          <guid>https://auth0.com/blog/2015/05/04/design-at-auth0</guid>
          <description>

&lt;p&gt;&lt;img src=&quot;http://assets.auth0.com/blog/design-process/sites.png&quot; class=&quot;expand&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For the past year Auth0 has been growing at a fast pace and naturally so has the number of fronts the Design Team has had to tackle.&lt;/p&gt;

&lt;p&gt;In this post we’ll explain what we&#39;ve learned as we’ve implemented practices that help integrate design into our products, guarantee consistency, and optimize design choices.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://assets.auth0.com/blog/design-process/process.png&quot; class=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;Blueprints&lt;/h3&gt;

&lt;p&gt;The first practice we introduced was design from blueprints. A blueprint is just a monochrome draft of the final product, with as little focus on styling as possible.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://assets.auth0.com/blog/design-process/blueprint.png&quot; class=&quot;expand&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We go through a lot of feedback from different company stakeholders, including engineers, marketers, analytics, or our own clients. By taking subjective factors like color or embellishment out of the process, blueprints help us get better feedback and achieve simpler solutions in a shorter length of time.&lt;/p&gt;

&lt;h3&gt;Asset production&lt;/h3&gt;

&lt;p&gt;We constantly review previous work when producing new assets to check for consistency and understand how they have evolved over time, so we don’t repeat mistakes.&lt;/p&gt;

&lt;p&gt;Our website is mapped out on a 1:1 scale with design files and is available to the whole team on Dropbox.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://assets.auth0.com/blog/design-process/dropbox.png&quot; class=&quot;expand&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Using Sketch has dramatically improved the way we create and export assets. We think it’s the best tool for the job because it was designed with the web in mind.&lt;/p&gt;

&lt;!-- With its numerous built-in templates, it allows us to jump right into design. We reuse most of our visual components, and working with the all-vector graphics saves us huge amounts of time when we&#39;re making changes to them. Exporting 1x, 2x, and SVG assets at a one-click distance is also ridiculously easy. --&gt;


&lt;h3&gt;Mobile first front-end work&lt;/h3&gt;

&lt;p&gt;Most of the HTML and CSS at Auth0 its handled or refactored by a designer at some point. We’ve set  &lt;a href=&quot;https://github.com/auth0/code-conventions/blob/master/frontend/README.md&quot;&gt;clear guidelines&lt;/a&gt; for front-end code, and we’ve chosen &lt;a href=&quot;https://learnboost.github.io/stylus/&quot;&gt;stylus&lt;/a&gt; and &lt;a href=&quot;http://jade-lang.com/&quot;&gt;jade&lt;/a&gt; to optimize our productivity. As a result, we write concise, clear code much faster.&lt;/p&gt;

&lt;p&gt;Over the past year, we started to migrate all of our pages as part of a mobile-first strategy.&lt;/p&gt;

&lt;p&gt;The rationale behind this strategy starts with the design perspective: we set out to only present information that we can make available in a way that works on any device. This simplifies our approach to information architecture by getting rid of unnecessary elements and solving problems in the simplest way, which also reduces the potential for errors during development.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://assets.auth0.com/blog/design-process/mobile-first.png&quot; class=&quot;expand&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In order to maintain stability, we are making these changes progressively. Each page that gets a redesign gets a mobile-first refactor to go with it.&lt;/p&gt;

&lt;p&gt;A key factor in preventing Responsive Design from getting messy was abstracting all of our media queries to a &lt;a href=&quot;https://github.com/auth0/styleguide/blob/master/lib/mixins/index.styl#L11&quot;&gt;stylus mixin&lt;/a&gt; and keeping them as close as possible to their relevant selectors, thus making them harder to overlook and easier to maintain.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.hero-cta
  color: blue;
  border-radius: 3px;
  padding: 10px 20px;
  max-width: 100%;

  +breakpoint(&quot;tablet&quot;)
    max-width: 620px;
    font-size: 18px;

  +breakpoint(&quot;desktop&quot;)
    max-width: 740px;
    font-size: 20px;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Styleguide for consistency&lt;/h3&gt;

&lt;p&gt;Styleguide is one of our most important projects. Its aim is to help maintain the same look and feel across all of our products and to make our front-end code reusable, no matter the specifics of any project&#39;s codebase.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://styleguide.auth0.com&quot;&gt;&lt;img src=&quot;http://assets.auth0.com/blog/design-process/styleguide.png&quot; class=&quot;expand&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Styleguide holds values, patterns, and specific components that repeat themselves across pages, enabling designers and engineers to  quickly reuse them on any product without worrying about markup or css.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://assets.auth0.com/blog/design-process/consistency.png&quot; class=&quot;expand&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Elements like our &lt;a href=&quot;https://github.com/auth0/web-header&quot;&gt;Header&lt;/a&gt;, Footer, and other components are easily maintained on different projects by sourcing them directly from &lt;a href=&quot;https://styleguide.auth0.com&quot;&gt;Styleguide&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;By reducing complex html structures and patterns to jade mixins available through &lt;a href=&quot;https://styleguide.auth0.com&quot;&gt;Styleguide&lt;/a&gt; and passing only content as parameters, we optimize development time.
&lt;!-- &lt;img src=&quot;http://assets.auth0.com/blog/design-process/icons.png&quot; class=&quot;&quot; /&gt; --&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Company &lt;a href=&quot;https://styleguide.auth0.com/#colors&quot;&gt;colors&lt;/a&gt;, &lt;a href=&quot;https://styleguide.auth0.com/#typography&quot;&gt;typography&lt;/a&gt;, and &lt;a href=&quot;https://styleguide.auth0.com/#icons&quot;&gt;icons&lt;/a&gt; are kept consistent by using the same set of variables and files for every project.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We use &lt;a href=&quot;http://semver.org/&quot;&gt;semantic versioning&lt;/a&gt; to enforce certain versions of Styleguide across projects. This helps maintain stability in our sites when we&#39;re doing heavy updates.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Today, we can include Styleguide using Bower, Component() or linking &lt;a href=&quot;https://cdn.auth0.com/styleguide/latest/index.css&quot;&gt;directly from the CDN&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you are interested, &lt;a href=&quot;https://styleguide.auth0.com&quot;&gt;check the live version&lt;/a&gt; or &lt;a href=&quot;https://github.com/auth0/styleguide&quot;&gt;view the code on Github&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Design Meetings&lt;/h3&gt;

&lt;p&gt;Though we’re still a small group, there are already different kinds of designers on the team, some more adept in usability or visual design, and some more focused on prototyping and code.&lt;/p&gt;

&lt;blockquote class=&quot;instagram-media&quot; data-instgrm-captioned data-instgrm-version=&quot;4&quot; style=&quot; background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:658px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);&quot;&gt;&lt;div style=&quot;padding:8px;&quot;&gt; &lt;div style=&quot; background:#F8F8F8; line-height:0; margin-top:40px; padding:50% 0; text-align:center; width:100%;&quot;&gt; &lt;div style=&quot; background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAAGFBMVEUiIiI9PT0eHh4gIB4hIBkcHBwcHBwcHBydr+JQAAAACHRSTlMABA4YHyQsM5jtaMwAAADfSURBVDjL7ZVBEgMhCAQBAf//42xcNbpAqakcM0ftUmFAAIBE81IqBJdS3lS6zs3bIpB9WED3YYXFPmHRfT8sgyrCP1x8uEUxLMzNWElFOYCV6mHWWwMzdPEKHlhLw7NWJqkHc4uIZphavDzA2JPzUDsBZziNae2S6owH8xPmX8G7zzgKEOPUoYHvGz1TBCxMkd3kwNVbU0gKHkx+iZILf77IofhrY1nYFnB/lQPb79drWOyJVa/DAvg9B/rLB4cC+Nqgdz/TvBbBnr6GBReqn/nRmDgaQEej7WhonozjF+Y2I/fZou/qAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;p style=&quot; margin:8px 0 0 0; padding:0 4px;&quot;&gt; &lt;a href=&quot;https://instagram.com/p/2HXZopiTi7/&quot; style=&quot; color:#000; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none; word-wrap:break-word;&quot; target=&quot;_top&quot;&gt;Design Meeting @auth0&lt;/a&gt;&lt;/p&gt; &lt;p style=&quot; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;&quot;&gt;A photo posted by Ricardo Rauch (@rickyrauch) on &lt;time style=&quot; font-family:Arial,sans-serif; font-size:14px; line-height:17px;&quot; datetime=&quot;2015-04-30T22:01:28+00:00&quot;&gt;Apr 30, 2015 at 3:01pm PDT&lt;/time&gt;&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;


&lt;script async defer src=&quot;//platform.instagram.com/en_US/embeds.js&quot;&gt;&lt;/script&gt;


&lt;p&gt;We have established weekly design meetings as a simple “show and tell” exercise to feed off each other&#39;s work and be in the loop of what’s been going on during the week with other projects. This adds a big picture perspective to all the work that&#39;s been done and complements daily feedback by showing the whole team the impact of design on our products.&lt;/p&gt;

&lt;p&gt;That’s it.&lt;/p&gt;

&lt;p&gt;We’re are always looking for ways to improve and optimize our process. We hope some of our practices can prove useful for anyone interested on collaborating in product design, and if you have suggestions or thoughts we’d be glad to hear them.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Announcing the Auth0 Open Source Single-Sign-On Dashboard</title>
          <link>https://auth0.com/blog/2015/04/28/announcing-auth0-sso-dashboard/</link>
          <pubDate>Tue, 28 Apr 2015 10:00:00 -0300</pubDate>
          <author>Nathan Totten</author>
          <avatar>https://www.gravatar.com/avatar/d48b998c2dce49ca309710eba498c562.png?s=60</avatar>
          <guid>https://auth0.com/blog/2015/04/28/announcing-auth0-sso-dashboard</guid>
          <description>&lt;p&gt;&lt;strong&gt;tl;dr&lt;/strong&gt;: Control which apps your users can access with an SSO dashboard. Download the &lt;a href=&quot;https://github.com/auth0/auth0-sso-dashboard&quot;&gt;code&lt;/a&gt; or &lt;a href=&quot;https://dashboard.heroku.com/new?template=https%3A%2F%2Fgithub.com%2Fauth0%2Fauth0-sso-dashboard&quot;&gt;deploy to Heroku&lt;/a&gt; in 5 minutes.&lt;/p&gt;

&lt;p&gt;Today, we are excited to announce the release of the Auth0 &lt;a href=&quot;https://github.com/auth0/auth0-sso-dashboard&quot;&gt;Open Source Single-Sign-On Dashboard&lt;/a&gt;. This SSO dashboard is designed to solve a problem familiar to many people. Organizations of all sizes maintain a variety of different applications to handle various business functions like accounting, HR, development, support, etc. Remembering usernames and passwords and login urls for all of these apps is a pain. With this app we take another step in simplifying the authentication experience.&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;&lt;img src=&quot;https://cloudup.com/cfENOYpKxfL+&quot; alt=&quot;SSO Dashboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can find the entire source of this project on &lt;a href=&quot;https://github.com/auth0/auth0-sso-dashboard&quot;&gt;Github&lt;/a&gt; along with instructions on how to deploy and configure a dashboard for your own organization. Additionally, you can try out a demo version (with non-functional apps) at &lt;a href=&quot;https://ssodashboard.herokuapp.com&quot;&gt;https://ssodashboard.herokuapp.com&lt;/a&gt;. Username: &lt;code&gt;publicdemo&lt;/code&gt; Password: &lt;code&gt;TestUser123&lt;/code&gt;. This demo only shows the user functionality; if you would like to see the full admin capabilities, please deploy your own instance.&lt;/p&gt;

&lt;p&gt;A few key features of the SSO Dashboard:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Landing page showing all apps that a user is allowed to access.&lt;/li&gt;
&lt;li&gt;Self-service user profile updates.&lt;/li&gt;
&lt;li&gt;Administrator interface for configuring roles, apps, and users.&lt;/li&gt;
&lt;li&gt;Completely customizable UI.&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Completely Open Source&lt;/h2&gt;

&lt;p&gt;Our approach to this project, like many projects at Auth0, was to build this as an open source app. This approach gives our users the most flexibility while still being very easy to maintain and receive updates.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Node.js Backend (Express)&lt;/li&gt;
&lt;li&gt;React, Flux, and React-Router&lt;/li&gt;
&lt;li&gt;Bootstrap (&lt;a href=&quot;https://bootswatch.com/paper/&quot;&gt;Paper Theme&lt;/a&gt;) and &lt;a href=&quot;http://callemall.github.io/material-ui/#/&quot;&gt;Material UI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; to enable ES6&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt; for asset bundling&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Feel free to fork and clone this project. We will accept pull requests and &lt;a href=&quot;https://github.com/auth0/auth0-sso-dashboard/issues&quot;&gt;issues&lt;/a&gt; if you want to contribute back.&lt;/p&gt;

&lt;p&gt;If this is something you have been looking for at your company or organization do give it a try. Let us know what you think, we will be adding features based on feedback.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Auth0 Europe Launches</title>
          <link>https://auth0.com/blog/2015/04/27/auth0-europe-launches/</link>
          <pubDate>Mon, 27 Apr 2015 13:26:00 -0300</pubDate>
          <author>José F. Romaniello</author>
          <avatar>https://www.gravatar.com/avatar/4d44bd6c8bbd97dfeb5e9c299aaa68c5</avatar>
          <guid>https://auth0.com/blog/2015/04/27/auth0-europe-launches</guid>
          <description>&lt;p&gt;Today we&#39;re happy to announce the launch of the &lt;strong&gt;Auth0 Europe&lt;/strong&gt; region. Auth0 makes identity simple for tens of thousands of developers in more than 150 countries around the world, and now those topographically closer to Frankfurt can enjoy even lower latency logins.  Further, subscribers everywhere that have the compliance requirement of EU data residence can check that box.&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;&lt;img src=&quot;https://cdn.auth0.com/blog/eu-launch.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;One Auth0, Two Continents&lt;/h2&gt;

&lt;p&gt;New subscribers now have the ability to specify their preferred region - Europe or the US - by simply selecting a location when creating their free developer account. Existing subscribers who are currently running from the US region who want to switch can just let us know and we&#39;ll handle migration. A number of Auth0 subscribers have already migrated to the European region and have reported a quick and easy transition.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.auth0.com/blog/multiregion.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;Faster than ever&lt;/h2&gt;

&lt;p&gt;Choosing a service region closer to where your customers are operating can mean some pretty awesome improvements in login latency. Subscribers in Europe who are already running from the European region have seen latency improvements of nearly 2x when compared to running from the US region, meaning even faster logins.&lt;/p&gt;

&lt;h2&gt;Migration from US&lt;/h2&gt;

&lt;p&gt;If you’d like to move from the US region to the EU region, simply let us know and we&#39;ll migrate your configuration/data. Once done, it’s just a simple change in your application so that it points to &lt;code&gt;https://&amp;lt;account&amp;gt;.eu.auth0.com&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;Safe Harbor&lt;/h2&gt;

&lt;p&gt;Auth0 has always and will continue to comply with the U.S.-EU Safe Harbor Framework and the U.S.-Swiss Safe Harbor Framework as set forth by the US Department of Commerce regarding the collection, use and retention of personal information from European Union member countries and Switzerland. Auth0 has certified that it adheres to the Safe Harbor Privacy Principles of notice, choice, onward transfer, security, data integrity, access, and enforcement. To learn more about the Safe Harbor program, and to view our certification page, please visit http://www.export.gov/safeharbor/.&lt;/p&gt;

&lt;h2&gt;We&#39;re here to help.&lt;/h2&gt;

&lt;p&gt;As always, we&#39;d be happy to answer any questions or provide assistance related to the new European region, or anything else. Send an email to &lt;a href=&quot;mailto:support@auth0.com&quot;&gt;support@auth0.com&lt;/a&gt;, chat with us at https://chat.auth0.com or ask questions at ask.auth0.com.&lt;/p&gt;

&lt;p&gt;We look forward to hearing from you!&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Update of the user's details section</title>
          <link>https://auth0.com/blog/2015/04/15/update-of-the-user-details-section/</link>
          <pubDate>Wed, 15 Apr 2015 15:57:00 -0300</pubDate>
          <author>Pablo Terradillos</author>
          <avatar>https://s.gravatar.com/avatar/647b1eea820b3fc8a5aee0383930b888?s=60</avatar>
          <guid>https://auth0.com/blog/2015/04/15/update-of-the-user-details-section</guid>
          <description>&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We have redesigned the user&#39;s profile page to use the new &lt;a href=&quot;https://auth0.com/docs/apiv2&quot;&gt;API v2&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;API v2 brings an improved way of &lt;a href=&quot;https://auth0.com/docs/apiv2Changes#8&quot;&gt;handling metadata&lt;/a&gt;. In short, metadata will be stored in a separate section (&lt;strong&gt;app_metadata&lt;/strong&gt; and &lt;strong&gt;user_metadata&lt;/strong&gt;) on the user structure and not merged with root attributes, which had caused confusion before.&lt;/li&gt;
&lt;li&gt;The data you&#39;ve modified in our previous dashboard version or using API v1 is now under &lt;strong&gt;app_metadata&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;This is a change on the &lt;strong&gt;Dashboard&lt;/strong&gt;, not on the runtime. There are &lt;strong&gt;no breaking changes&lt;/strong&gt; to your apps.&lt;/li&gt;
&lt;/ul&gt;


&lt;!-- more --&gt;


&lt;p&gt;Good news! We have redesigned the user&#39;s profile page in order to make use of the new &lt;a href=&quot;https://auth0.com/docs/apiv2&quot;&gt;API v2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;User&#39;s data is now separated in three sections, each one with different meanings according to what it represents.&lt;/p&gt;

&lt;h3&gt;User Identity Section&lt;/h3&gt;

&lt;p&gt;On the main section you will find essential data such as the user&#39;s email and login access information.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.auth0.com/blog/new-profile-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;Metadata Section&lt;/h3&gt;

&lt;p&gt;The &lt;strong&gt;Metadata&lt;/strong&gt; section is the part of the user&#39;s data that you can modify.&lt;/p&gt;

&lt;p&gt;In the previous user&#39;s profile, the &lt;em&gt;metadata&lt;/em&gt; was merged with the user&#39;s root-level attributes which created some confusion. To make everythig more explicit and easier to find, we&#39;ve decided to keep it separate.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.auth0.com/blog/new-profile-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If you modified user attributes in the past through the dashboard, you will find the additional attributes under &lt;strong&gt;app_metadata&lt;/strong&gt;  after this change (since the dashboard was using API v1).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://auth0.com/docs/apiv2Changes#8&quot;&gt;Learn more&lt;/a&gt; about when to use &lt;strong&gt;app_metadata&lt;/strong&gt; vs &lt;strong&gt;user_metadata&lt;/strong&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;Identity Provider Attributes Section&lt;/h3&gt;

&lt;p&gt;Last but not least, there&#39;s the &lt;strong&gt;Identity Provider Attributes&lt;/strong&gt; section. Here you will find all the information retrieved from the authentication provider (e.g. Facebook, Twitter, Google, SAML, your own provider, etc.).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.auth0.com/blog/new-profile-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This data is read-only. Let&#39;s say you&#39;d like to modify the picture that is coming from the Facebook profile. You won&#39;t be able to change the attribute in the &lt;strong&gt;Identity Provider Attributes&lt;/strong&gt; section. Instead you need to set the &lt;code&gt;picture&lt;/code&gt; attribute in the &lt;code&gt;user_metadata&lt;/code&gt; property and then in your application you would do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&quot;&amp;lt;%= user.user_metadata.picture || user.picture %&amp;gt;&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The previous code snippet tries to use the &lt;code&gt;picture&lt;/code&gt; property from &lt;code&gt;user_metadata&lt;/code&gt; and if it doesn&#39;t exist it uses the default (&lt;code&gt;user.picture&lt;/code&gt;).&lt;/p&gt;

&lt;h3&gt;Raw JSON&lt;/h3&gt;

&lt;p&gt;Finally, you can easily take a look at the raw JSON format that will be served by our API at the new &lt;strong&gt;Raw JSON&lt;/strong&gt; tab.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.auth0.com/blog/new-profile-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Adding authentication to your React Flux app</title>
          <link>https://auth0.com/blog/2015/04/09/adding-authentication-to-your-react-flux-app/</link>
          <pubDate>Thu, 09 Apr 2015 11:22:00 -0300</pubDate>
          <author>Martin Gontovnikas</author>
          <avatar>https://www.gravatar.com/avatar/df6c864847fba9687d962cb80b482764?size=200</avatar>
          <guid>https://auth0.com/blog/2015/04/09/adding-authentication-to-your-react-flux-app</guid>
          <description>&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;: You can check out a React Flux app with authentication implemented in &lt;a href=&quot;https://github.com/auth0/react-flux-jwt-authentication-sample&quot;&gt;this Github repository&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Let’s face it. &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; is the new cool kid on the block. Everybody is working on creating React components because it entails understanding just 2 basic concepts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A component is just a function&lt;/li&gt;
&lt;li&gt;Single-direction data flow&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;However, once you start creating a bigger app, you realize that just using React isn’t enough. So you start looking at &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;, which is the architecture Facebook uses to create React apps.&lt;/p&gt;

&lt;p&gt;As we learned in a &lt;a href=&quot;https://auth0.com/blog/2014/01/07/angularjs-authentication-with-cookies-vs-token/&quot;&gt;previous blog post&lt;/a&gt;, learning how to conduct authentication in a Single Page App can get super complex. We had to learn about tokens, &lt;a href=&quot;http://jwt.io/&quot;&gt;JWTs&lt;/a&gt; and how to integrate them with SPAs. Learning how to do it with Flux is even harder! That’s why in this blogpost we’ll learn how to add authentication to a React Flux app.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.google.com/drawings/d/12Y8gWirtVhvrHrlyc1Z7P59c2NkY6m3zThsSL1L0gP0/pub?w=959&amp;amp;h=638&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h2&gt;Before we start&lt;/h2&gt;

&lt;p&gt;We’ll be coding our React app using ES6 thanks to &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; and &lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify&lt;/a&gt;, and we’ll be using npm for build tools and installing dependencies. If you want to start a project with the same architecture, just clone &lt;a href=&quot;https://github.com/auth0/react-browserify-spa-seed&quot;&gt;this seed project&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Let’s code!&lt;/h2&gt;

&lt;h3&gt;Login page&lt;/h3&gt;

&lt;h4&gt;The Login component&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.google.com/drawings/d/1DVqDnn7YnNd-YJieoAVlwxrGyDpCZEZH9nCpNs3KbO0/pub?w=959&amp;amp;h=638&quot; alt=&quot;Login Component&quot; /&gt;&lt;/p&gt;

&lt;p&gt;First, let’s create our &lt;code&gt;Login&lt;/code&gt; component. Its main function is rendering an input for the username and password and calling the &lt;code&gt;AuthService&lt;/code&gt; when the user clicks on the login button.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx&quot;&gt;// ... imports
export default class Login extends React.Component {

  constructor() {
    this.state = {
      user: ‘’,
      password: ‘’
    };
  }

  // This will be called when the user clicks on the login button
  login(e) {
    e.preventDefault();
    // Here, we call an external AuthService. We’ll create it in the next step
    Auth.login(this.state.user, this.state.password)
      .catch(function(err) {
        console.log(“Error logging in”, err);
      });
  }

  render() {
    return (
        &amp;lt;form role=“form”&amp;gt;
        &amp;lt;div className=“form-group”&amp;gt;
          &amp;lt;input type=“text” valueLink={this.linkState(‘user’)}placeholder=“Username” /&amp;gt;
          &amp;lt;input type=“password” valueLink={this.linkState(‘password’)} placeholder=“Password” /&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;button type=“submit” onClick={this.login.bind(this)}&amp;gt;Submit&amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
    &amp;lt;/div&amp;gt;
    );
  }
}

// We’re using the mixin `LinkStateMixin` to have two-way databinding between our component and the HTML.
reactMixin(Login.prototype, React.addons.LinkedStateMixin);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;The AuthService &amp;amp; the LoginAction&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.google.com/drawings/d/1FFBWhfS7hqtq4qcXXsNEtOW2T8f5RkEiq50D4MTlDyw/pub?w=959&amp;amp;h=638&quot; alt=&quot;Authseervice and login action&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Our AuthService is in charge of calling our &lt;a href=&quot;https://github.com/auth0/nodejs-jwt-authentication-sample/blob/master/user-routes.js#L37-L54&quot;&gt;login API&lt;/a&gt;. The server will validate the username and password and return a token &lt;a href=&quot;http://jwt.io/&quot;&gt;(JWT)&lt;/a&gt; back to our app. Once we get it, we’ll create a &lt;a href=&quot;https://facebook.github.io/flux/docs/todo-list.html#creating-semantic-actions&quot;&gt;LoginAction&lt;/a&gt; and send it to all the &lt;a href=&quot;https://facebook.github.io/flux/docs/todo-list.html#creating-stores&quot;&gt;Stores&lt;/a&gt; using the &lt;a href=&quot;https://facebook.github.io/flux/docs/todo-list.html#creating-a-dispatcher&quot;&gt;Dispatcher&lt;/a&gt; from Flux.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx&quot;&gt;// AuthService.js
// ... imports
class AuthService {

  login(username, password) {
    // We call the server to log the user in.
    return when(request({
      url: ‘http://localhost:3001/sessions/create&#39;,
      method: ‘POST’,
      crossOrigin: true,
      type: ‘json’,
      data: {
        username, password
      }
    }))
    .then(function(response) {
        // We get a JWT back.
        let jwt = response.id_token;
        // We trigger the LoginAction with that JWT.
        LoginActions.loginUser(jwt);
        return true;
    });
  }
}

export default new AuthService()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// LoginAction.js
// ... imports
export default {
  loginUser: (jwt) =&amp;gt; {
    // Go to the Home page once the user is logged in
    RouterContainer.get().transitionTo(‘/‘);
    // We save the JWT in localStorage to keep the user authenticated. We’ll learn more about this later.
    localStorage.setItem(‘jwt’, jwt);
    // Send the action to all stores through the Dispatcher
    AppDispatcher.dispatch({
      actionType: LOGIN_USER,
      jwt: jwt
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can take a look at the router configuration &lt;a href=&quot;https://github.com/auth0/react-flux-jwt-authentication-sample/blob/gh-pages/src/app.jsx#L11-L29&quot;&gt;on Github&lt;/a&gt;, but it’s important to note that once the &lt;code&gt;LoginAction&lt;/code&gt; is triggered, the user is successfully authenticated. Therefore, we need to redirect him or her from the Login page to the Home. That’s why we’re adding the URL transition in here.&lt;/p&gt;

&lt;h4&gt;The LoginStore&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.google.com/drawings/d/1_IAM5yjabjPK6EGq7dfliV_rRISTrsT7BlKl9MSX1D0/pub?w=959&amp;amp;h=638&quot; alt=&quot;Dispatcher and LoginStore&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The LoginStore, like any other store, has 2 functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It holds the data it gets from the actions. In our case, that data will be used by all components that need to display the user information.&lt;/li&gt;
&lt;li&gt;It inherits from &lt;code&gt;EventEmmiter&lt;/code&gt;. It’ll emit a change event every time its data changes so that Components can be rendered again.&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;jsx&quot;&gt;// ... imports
class LoginStore extends BaseStore {

  constructor() {
    // First we register to the Dispatcher to listen for actions.
    this.dispatchToken = AppDispatcher.register(this._registerToActions.bind(this));
    this._user = null;
    this._jwt = null;
  }

  _registerToActions(action) {
    switch(action.actionType) {
      case USER_LOGGED_IN:
        // We get the JWT from the action and save it locally.
        this._jwt = action.jwt;
        // Then we decode it to get the user information.
        this._user = jwt_decode(this._jwt);
        // And we emit a change to all components that are listening.
        // This method is implemented in the `BaseStore`.
        this.emitChange();
        break;
      default:
        break;
    };
  }

  // Just getters for the properties it got from the action.
  get user() {
    return this._user;
  }

  get jwt() {
    return this._jwt;
  }

  isLoggedIn() {
    return !!this._user;
  }
}
export default new LoginStore();
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;You can take a look at the &lt;code&gt;BaseStore&lt;/code&gt; &lt;a href=&quot;https://github.com/auth0/react-flux-jwt-authentication-sample/blob/gh-pages/src/stores/BaseStore.js&quot;&gt;in Github&lt;/a&gt;. It includes some utility methods that all stores will have.&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3&gt;Displaying the user information&lt;/h3&gt;

&lt;h4&gt;Creating an Authenticated component&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.google.com/drawings/d/1LlRJ_EC6M11wLzGgicTv5DJGOOxMGl4P-yX5LfvGlgs/pub?w=959&amp;amp;h=638&quot; alt=&quot;AuthenticatedComponent&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, we can start creating components that require authentication. For that, we’ll create a wrapper (or decorator) component called &lt;code&gt;AuthenticatedComponent&lt;/code&gt;. It’ll make sure the user is authenticated before displaying its content. If the user isn’t authenticated, it’ll redirect him or her to the Login page. Otherwise, it’ll send the user information to the component it’s wrapping:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx&quot;&gt;// ... imports
export default (ComposedComponent) =&amp;gt; {
  return class AuthenticatedComponent extends React.Component {

    static willTransitionTo(transition) {
      // This method is called before transitioning to this component. If the user is not logged in, we’ll send him or her to the Login page.
      if (!LoginStore.isLoggedIn()) {
        transition.redirect(‘/login’);
      }
    }

    constructor() {
      this.state = this._getLoginState();
    }

    _getLoginState() {
      return {
        userLoggedIn: LoginStore.isLoggedIn(),
        user: LoginStore.user,
        jwt: LoginStore.jwt
      };
    }

    // Here, we’re subscribing to changes in the LoginStore we created before. Remember that the LoginStore is an EventEmmiter.
    componentDidMount() {
      LoginStore.addChangeListener(this._onChange.bind(this));
    }

    // After any change, we update the component’s state so that it’s rendered again.
    _onChange() {
      this.setState(this._getLoginState());
    }

    componentWillUnmount() {
        LoginStore.removeChangeListener(this._onChange.bind(this));
    }

    render() {
      return (
      &amp;lt;ComposedComponent
        {...this.props}
        user={this.state.user}
        jwt={this.state.jwt}
        userLoggedIn={this.state.userLoggedIn} /&amp;gt;
      );
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An interesting pattern is used here.
First, take a look at what we’re exporting. We’re exporting a function that receives a Component as a parameter and then returns a new Component that wraps the one that was sent as an argument.
Next, take a look at the &lt;code&gt;render&lt;/code&gt; method. There, we’re rendering the Component we received as a parameter. Besides the &lt;code&gt;props&lt;/code&gt; it should receive, we’re also sending it all the user information so it can use those properties.
Now, let’s create the Home component which will be wrapped by the &lt;code&gt;AuthenticatedComponent&lt;/code&gt; we’ve just created.&lt;/p&gt;

&lt;h4&gt;Home Page&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.google.com/drawings/d/1kZBxoxkMMQe2-VZb1kJPjoQQ3EZ_kJ1lw1Bg2zQ9JG4/pub?w=959&amp;amp;h=638&quot; alt=&quot;Home&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Home&lt;/code&gt; will display user information. As it’s wrapped by the &lt;code&gt;AuthenticatedComponent&lt;/code&gt;, we can be sure of 2 things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Once the &lt;code&gt;render&lt;/code&gt; method is called on the &lt;code&gt;Home&lt;/code&gt; component, we know the user is authenticated. Otherwise, the app would have redirected him to the &lt;code&gt;Login&lt;/code&gt; page.&lt;/li&gt;
&lt;li&gt;We know we’ll have the user information under &lt;code&gt;props&lt;/code&gt; because we’ve received them from the &lt;code&gt;AuthenticatedComponent&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;jsx&quot;&gt;// ... imports
// We’re wrapping the home with the AuthenticatedComponent
export default AuthenticatedComponent(class Home extends React.Component {
  render() {
     // Here, we display the user information
    return (&amp;lt;h1&amp;gt;Hello {this.props.user.username}&amp;lt;/h1&amp;gt;);
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Let’s call an API!&lt;/h3&gt;

&lt;p&gt;Now, you should be able to call an API. In order to call an API that requires authentication, you must send the JWT we received on Login in the &lt;code&gt;Authorization&lt;/code&gt; header. Any &lt;code&gt;AuthenticatedComponent&lt;/code&gt; has access to this JWT so you can do something as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx&quot;&gt;// Home.jsx
// It must be on an AuthenticatedComponent
callApi() {
  fetch(‘http://example.com/my-cool-url&#39;, {
    method: ‘GET’,
    headers: {
      Authorization: ‘Bearer ‘ + this.props.jwt
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Keeping the user authenticated&lt;/h3&gt;

&lt;p&gt;Now that the user is authenticated, we want to keep him or her authenticated instead of showing the login page every time he refreshes the website.
Due to the fact we’re saving the JWT on &lt;code&gt;localStorage&lt;/code&gt; after a successful authentication, we can manually trigger the &lt;code&gt;LoginAction&lt;/code&gt; and everything will work. That’s the beauty of using Flux.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// app.jsx ==&amp;gt; Bootstrap file
let jwt = localStorage.getItem(‘jwt’);
if (jwt) {
  LoginActions.loginUser(jwt);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Closing remarks&lt;/h2&gt;

&lt;p&gt;We’ve finished implementing the Login for a React Flux app. If you want to know how to implement a signup or if you want to see the full example at work, you can &lt;a href=&quot;https://github.com/auth0/react-flux-jwt-authentication-sample&quot;&gt;grab the code from Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Happy Hacking! :).&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Using TouchID for Authentication in your React Native app</title>
          <link>https://auth0.com/blog/2015/04/03/using-touchid-for-authentication-in-your-react-native-app/</link>
          <pubDate>Fri, 03 Apr 2015 17:47:00 -0300</pubDate>
          <author>Hernan Zalazar</author>
          <avatar>https://www.gravatar.com/avatar/b93af62499ed0f76f280acb37913f15d.png?size=200</avatar>
          <guid>https://auth0.com/blog/2015/04/03/using-touchid-for-authentication-in-your-react-native-app</guid>
          <description>&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;: You can see a sample of how to use &lt;strong&gt;TouchID with React Native&lt;/strong&gt; in &lt;strong&gt;&lt;a href=&quot;https://github.com/auth0/Lock.ReactNative/tree/master/Example&quot;&gt;this Github repository&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;A few days ago, Facebook finally made &lt;strong&gt;React Native&lt;/strong&gt; available in &lt;a href=&quot;https://github.com/facebook/react-native&quot;&gt;Github&lt;/a&gt;, so, like everybody else, we decided to give it a try.
After the usual “Hello, World” examples and test applications, we were pretty amazed at how easy it was to code a native app with Javascript.
This is when we decided to try implementing something a little more complicated like &lt;strong&gt;TouchID authentication&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;We’ve checked React Native components and couldn’t find one that allows us to use TouchID, so we went back to &lt;em&gt;good ol’ Objective-C&lt;/em&gt; since there is no support for &lt;em&gt;Swift&lt;/em&gt; yet. We decided to code a &lt;a href=&quot;http://facebook.github.io/react-native/docs/nativemodulesios.html#content&quot;&gt;React Native Module&lt;/a&gt; that would allow everyone to use TouchID.
Here in Auth0, we&#39;ve already implemented a TouchID authentication flow for &lt;a href=&quot;https://github.com/auth0/Lock.iOS-OSX#touchid&quot;&gt;Lock&lt;/a&gt;. So we decided to reuse that library and wrap it in a React Native compatible library. In other words, we created &lt;a href=&quot;https://github.com/auth0/Lock.ReactNative&quot;&gt;Lock.ReactNative&lt;/a&gt; with all the necessary mappings to use Lock like this in your React Native app:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;Lock.show({
  connections: [&#39;touchid&#39;],
}, (err, profile, token) =&amp;gt; {
  /** Handle Login */
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this article, we&#39;ll learn how you can use &lt;code&gt;Lock.ReactNative&lt;/code&gt; in any new app you build to add authentication to it!&lt;/p&gt;

&lt;!-- more --&gt;


&lt;blockquote&gt;&lt;p&gt;Before starting, make sure you have React Native, Xcode and CocoaPods installed in your Mac. For that, you can use React Native’s &lt;a href=&quot;http://facebook.github.io/react-native/docs/getting-started.html#content&quot;&gt;Getting Started Guide&lt;/a&gt;, and Cocoa Pod&#39;s &lt;a href=&quot;http://guides.cocoapods.org/using/getting-started.html&quot;&gt;Getting Started Guide&lt;/a&gt; as well.&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;Project Creation &amp;amp; Configuration&lt;/h2&gt;

&lt;h3&gt;Installing the needed dependencies&lt;/h3&gt;

&lt;p&gt;Once our React Native app is created, we need to install LockReact as a dependency. For that, we&#39;ll use CocoaPods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;# Run in the React Native app&#39;s folder
pod init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit the &lt;code&gt;Podfile&lt;/code&gt; content to look as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;platform :iOS, &#39;8.0&#39;

target &#39;MyApp&#39; do
  pod &#39;LockReact&#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, just install the dependencies and open the XCode Project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;pod install
open LockReact.xcworkspace
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Configuring Lock&lt;/h3&gt;

&lt;p&gt;Now, let&#39;s create an application in your &lt;a href=&quot;https://manage.auth0.com/&quot;&gt;Auth0&lt;/a&gt; account and copy the &lt;code&gt;clientId&lt;/code&gt; and &lt;code&gt;domain&lt;/code&gt; to the &lt;code&gt;Info.plist&lt;/code&gt; file&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.auth0.com//blog/react-native-touchid/CreateApp.gif&quot; alt=&quot;Create Auth0 account&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;Make your JS code be able to call a native component&lt;/h3&gt;

&lt;p&gt;Finally, we need to create an Objective-C class (LockReactModule in this case) that will allow your JS code to call Lock&#39;s native component:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.auth0.com//blog/react-native-touchid/CreateClass.gif&quot; alt=&quot;Create ObjectiveC class&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, paste the following code into the created classes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;objc&quot;&gt;// LockReactModule.h file
#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &quot;RCTBridgeModule.h&quot;

@interface LockReactModule : NSObject&amp;lt;RCTBridgeModule&amp;gt;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;objc&quot;&gt;// LockReactModule.m file
#import &quot;LockReactModule.h&quot;
#import &amp;lt;LockReact/A0LockReact.h&amp;gt;

@implementation LockReactModule

- (void)show:(NSDictionary *)options callback:(RCTResponseSenderBlock)callback {
  RCT_EXPORT(show);
  dispatch_async(dispatch_get_main_queue(), ^{
    A0LockReact *lock = [[A0LockReact alloc] init];
    [lock showWithOptions:options callback:callback];
  });
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Authenticating with TouchID from JS&lt;/h2&gt;

&lt;p&gt;Now we&#39;re ready to write some JS code!. We want to show a simple UI like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.auth0.com//blog/react-native-touchid/appImage.png&quot; alt=&quot;Sample app&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;Implementing the UI&lt;/h3&gt;

&lt;p&gt;First, let&#39;s implement the base UI with a React component.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// Imports go here
// ...

var LockReactApp = React.createClass({
  render: function() {
    return (
      &amp;lt;View style={styles.container}&amp;gt;
        &amp;lt;Text style={styles.message}&amp;gt;
          Please tap on &#39;Login with TouchID&#39; to continue.
        &amp;lt;/Text&amp;gt;
        &amp;lt;View style={styles.actionContainer}&amp;gt;
          &amp;lt;TouchableHighlight style={styles.actionButton} onPress={this._onLoginTouchID}&amp;gt;
            &amp;lt;Text style={styles.actionButtonText}&amp;gt;Login with TouchID&amp;lt;/Text&amp;gt;
          &amp;lt;/TouchableHighlight&amp;gt;
        &amp;lt;/View&amp;gt;
      &amp;lt;/View&amp;gt;
    );
  },
  _onLoginTouchID: function() {
    // Implement TouchID here
    console.log(&quot;Implement TouchID here!&quot;);
  }
});

// Styles go here
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Adding TouchID authentication with &lt;code&gt;Lock&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Now, we can just use &lt;code&gt;Lock&lt;/code&gt; for TouchID authentication.&lt;/p&gt;

&lt;p&gt;First, we require it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;var Lock = require(&#39;NativeModules&#39;).LockReactModule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we call it from the &lt;code&gt;_onLoginTouchID&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;Lock.show({
  closable: true,
  authParams: {
    connection: &#39;Username-Password-Authentication&#39;,
  },
  connections: [&#39;touchid&#39;],
}, (err, profile, token) =&amp;gt; {
  if (err) {
    console.log(err);
    return;
  }
  // Authentication worked!
  console.log(&#39;Logged in with TouchID!&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Refresh the app and boom!. Authenticating with TouchID now works.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.auth0.com//blog/react-native-touchid/AppFlow.gif&quot; alt=&quot;Working app&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Congrats, you&#39;ve just added TouchID to your app with less than 20 lines of code :). If you want to see the full code of this sample app, you can go to &lt;a href=&quot;https://github.com/auth0/Lock.ReactNative/tree/master/Example&quot;&gt;this github repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Happy hacking :)!&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Critical vulnerabilities in JSON Web Token libraries</title>
          <link>https://auth0.com/blog/2015/03/31/critical-vulnerabilities-in-json-web-token-libraries/</link>
          <pubDate>Tue, 31 Mar 2015 09:00:00 -0300</pubDate>
          <author>Tim McLean</author>
          <avatar>https://www.gravatar.com/avatar/dfea5c5f769cc4a6cce74d3eda20bba3?size=200</avatar>
          <guid>https://auth0.com/blog/2015/03/31/critical-vulnerabilities-in-json-web-token-libraries</guid>
          <description>&lt;blockquote&gt;&lt;p&gt;tl;dr If you are using &lt;a href=&quot;https://github.com/auth0/node-jsonwebtoken&quot;&gt;node-jsonwebtoken&lt;/a&gt;, &lt;a href=&quot;https://github.com/jpadilla/pyjwt/&quot;&gt;pyjwt&lt;/a&gt;, &lt;a href=&quot;https://github.com/namshi/jose&quot;&gt;namshi/jose&lt;/a&gt;, &lt;a href=&quot;https://github.com/firebase/php-jwt&quot;&gt;php-jwt&lt;/a&gt; or &lt;a href=&quot;https://github.com/kjur/jsjws&quot;&gt;jsjwt&lt;/a&gt; with asymmetric keys (RS256, RS384, RS512, ES256, ES384, ES512) please update to the latest version. See &lt;a href=&quot;http://jwt.io&quot;&gt;jwt.io&lt;/a&gt; for more information on the vulnerable libraries. &lt;em&gt;(Updated 2015-04-20)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is a guest post from Tim McLean, who is part of the &lt;a href=&quot;https://auth0.com/whitehat#hall-of-fame&quot;&gt;Auth0 Security Researcher Hall of Fame&lt;/a&gt;. Tim normally blogs at &lt;a href=&quot;https://www.timmclean.net&quot;&gt;www.timmclean.net&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Recently, while reviewing the security of various JSON Web Token
implementations, I found many libraries with critical vulnerabilities allowing
attackers to bypass the verification step.  The same two flaws were found
across many implementations and languages, so I thought it would be helpful to
write up exactly where the problems occur.  I believe that a change to the
standard could help prevent future vulnerabilities.&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;For those who are unfamiliar, JSON Web Token (JWT) is a standard for creating
tokens that assert some number of claims.  For example, a server could generate
a token that has the claim &quot;logged in as admin&quot; and provide that to a client.
The client could then use that token to prove that they are logged in as admin.
The tokens are signed by the server&#39;s key, so the server is able to verify that
the token is legitimate.&lt;/p&gt;

&lt;p&gt;JWTs generally have three parts: a header, a payload, and a signature.  The
header identifies which algorithm is used to generate the signature, and looks
something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;header = &#39;{&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;HS256&lt;/code&gt; indicates that this token is signed using HMAC-SHA256.&lt;/p&gt;

&lt;p&gt;The payload contains the claims that we wish to make:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;payload = &#39;{&quot;loggedInAs&quot;:&quot;admin&quot;,&quot;iat&quot;:1422779638}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As suggested in the JWT spec, we include a timestamp called &lt;code&gt;iat&lt;/code&gt;, short for
&quot;issued at&quot;.&lt;/p&gt;

&lt;p&gt;The signature is calculated by base64url encoding the header and payload and
concatenating them with a period as a separator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;key = &#39;secretkey&#39;
unsignedToken = encodeBase64(header) + &#39;.&#39; + encodeBase64(payload)
signature = HMAC-SHA256(key, unsignedToken)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To put it all together, we base64url encode the signature, and join together
the three parts using periods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;token = encodeBase64(header) + &#39;.&#39; + encodeBase64(payload) + &#39;.&#39; + encodeBase64(signature)

# token is now:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dnZWRJbkFzIjoiYWRtaW4iLCJpYXQiOjE0MjI3Nzk2Mzh9.gzSraSYS8EXBxLN_oWnFSRgCzcmJmMjLiuyu5CSpyHI
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Great.  So, what&#39;s wrong with that?&lt;/h2&gt;

&lt;p&gt;Well, let&#39;s try to verify a token.&lt;/p&gt;

&lt;p&gt;First, we need to determine what algorithm was used to generate the
signature.  No problem, there&#39;s an &lt;code&gt;alg&lt;/code&gt; field in the header that tells us just
that.&lt;/p&gt;

&lt;p&gt;But wait, we haven&#39;t validated this token yet, which means that we haven&#39;t
validated the header.  This puts us in an awkward position: in order to
validate the token, we have to allow attackers to select which method we use to
verify the signature.&lt;/p&gt;

&lt;p&gt;This has disastrous implications for some implementations.&lt;/p&gt;

&lt;h2&gt;Meet the &quot;none&quot; algorithm&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;none&lt;/code&gt; algorithm is a curious addition to JWT.  It is intended to be used
for situations where the integrity of the token has already been verified.
Interestingly enough, it is one of only two algorithms that are mandatory to
implement (the other being &lt;code&gt;HS256&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Unfortunately, some libraries treated tokens signed with the &lt;code&gt;none&lt;/code&gt; algorithm
as a valid token with a verified signature.  The result?  Anyone can create
their own &quot;signed&quot; tokens with whatever payload they want, allowing arbitrary
account access on some systems.&lt;/p&gt;

&lt;p&gt;Putting together such a token is easy.  Modify the above example header to
contain &lt;code&gt;&quot;alg&quot;: &quot;none&quot;&lt;/code&gt; instead of &lt;code&gt;HS256&lt;/code&gt;.  Make any desired changes to the
payload.  Use an empty signature (i.e. &lt;code&gt;signature = &quot;&quot;&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Most (hopefully all?) implementations now have a basic check to prevent this
attack: if a secret key was provided, then token verification will fail for
tokens using the &lt;code&gt;none&lt;/code&gt; algorithm.  This is a good idea, but it doesn&#39;t solve
the underlying problem: attackers control the choice of algorithm.  Let&#39;s keep
digging.&lt;/p&gt;

&lt;h2&gt;RSA or HMAC?&lt;/h2&gt;

&lt;p&gt;The JWT spec also defines a number of asymmetric signing algorithms (based on
RSA and ECDSA).  With these algorithms, tokens are created and signed using a
private key, but verified using a corresponding public key.  This is pretty
neat: if you publish the public key but keep the private key to yourself, only
you can sign tokens, but anyone can check if a given token is correctly signed.&lt;/p&gt;

&lt;p&gt;Most of the JWT libraries that I&#39;ve looked at have an API like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# sometimes called &quot;decode&quot;
verify(string token, string verificationKey)
# returns payload if valid token, else throws an error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In systems using HMAC signatures, &lt;code&gt;verificationKey&lt;/code&gt; will be the server&#39;s secret
signing key (since HMAC uses the same key for signing and verifying):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;verify(clientToken, serverHMACSecretKey)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In systems using an asymmetric algorithm, &lt;code&gt;verificationKey&lt;/code&gt; will be the public
key against which the token should be verified:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;verify(clientToken, serverRSAPublicKey)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, an attacker can abuse this.  If a server is expecting a token
signed with RSA, but actually receives a token signed with HMAC, &lt;strong&gt;it will
think the public key is actually an HMAC secret key&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;How is this a disaster?  HMAC secret keys are supposed to be kept private,
while public keys are, well, public.  This means that your typical &lt;a href=&quot;https://i.imgur.com/18fM5ja.jpg&quot;&gt;ski
mask-wearing attacker&lt;/a&gt; has access to the
public key, and can use this to forge a token that the server will accept.&lt;/p&gt;

&lt;p&gt;Doing so is pretty straightforward.  First, grab your favourite JWT library,
and choose a payload for your token.  Then, get the public key used on the
server as a verification key (most likely in the text-based PEM format).
Finally, sign your token using the PEM-formatted public key as an HMAC key.
Essentially:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;forgedToken = sign(tokenPayload, &#39;HS256&#39;, serverRSAPublicKey)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The trickiest part is making sure that &lt;code&gt;serverRSAPublicKey&lt;/code&gt; is identical to the
verification key used on the server.  The strings must match exactly for the
attack to work -- exact same format, and no extra or missing line breaks.&lt;/p&gt;

&lt;p&gt;End result?  Anyone with knowledge of the public key can forge tokens that will
pass verification.&lt;/p&gt;

&lt;h2&gt;Recommendations for Library Developers&lt;/h2&gt;

&lt;p&gt;I suggest that JWT libraries add an &lt;code&gt;algorithm&lt;/code&gt; parameter to their verification function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;verify(string token, string algorithm, string verificationKey)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The server should already know what algorithm it uses to sign tokens, and it&#39;s
not safe to allow attackers to provide this value.&lt;/p&gt;

&lt;p&gt;Some might argue that some servers need to support more than one algorithm for
compatibility reasons.  In this case, a separate key can (and should) be used
for each supported algorithm.  JWT conveniently provides a &quot;key ID&quot; field
(&lt;code&gt;kid&lt;/code&gt;) for exactly this purpose.  Since servers can use the key ID to look up
the key and its corresponding algorithm, attackers are no longer able to
control the manner in which a key is used for verification.  In any case, I
don&#39;t think JWT libraries should even look at the &lt;code&gt;alg&lt;/code&gt; field in the header,
except maybe to check that it matches what was the expected algorithm.&lt;/p&gt;

&lt;p&gt;Anyone using a JWT implementation should make sure that tokens with a different
signature type are guaranteed to be rejected.  Some libraries have an optional
mechanism for whitelisting or blacklisting algorithms; take advantage of it or
you might end up at risk.  Even better: have a policy of performing security
audits on any open source libraries that you use to provide mission-critical
funtionality.&lt;/p&gt;

&lt;h2&gt;Improving the JWT/JWS standard&lt;/h2&gt;

&lt;p&gt;I would like to propose deprecating the header&#39;s &lt;code&gt;alg&lt;/code&gt; field.  As we&#39;ve seen
here, its misuse can have a devastating impact on the security of a JWT/JWS
implementation.  As far as I can tell, key IDs provide an adequate alternative.
This warrants a change to the spec: JWT libraries continue to be written with
security flaws due to their dependence on &lt;code&gt;alg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;JWT (and JOSE) present the opportunity to have a cross-platform suite of secure
cryptography implementations.  With these fixes, hopefully we&#39;re a little bit
closer to making that a reality.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Blacklisting JSON Web Token API Keys</title>
          <link>https://auth0.com/blog/2015/03/10/blacklist-json-web-token-api-keys/</link>
          <pubDate>Tue, 10 Mar 2015 09:00:00 -0300</pubDate>
          <author>Damian Schenkelman</author>
          <avatar>https://www.gravatar.com/avatar/1c9619a22f32012221bd59296dc9a1a2?size=200</avatar>
          <guid>https://auth0.com/blog/2015/03/10/blacklist-json-web-token-api-keys</guid>
          <description>&lt;!-- &lt;a href=&quot;//cdn.auth0.com/blog/blacklist_header.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;//cdn.auth0.com/blog/blacklist_header.jpg&quot;&gt;&lt;/a&gt; --&gt;


&lt;p&gt;&lt;strong&gt;tl;dr&lt;/strong&gt;: if you understand why and how to support blacklisting JWTs, then skip to the &lt;a href=&quot;#impl&quot;&gt;code&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;On a &lt;a href=&quot;https://auth0.com/blog/2014/12/02/using-json-web-tokens-as-api-keys/&quot;&gt;previous post&lt;/a&gt; we proposed an approach to using JSON Web Tokens as API Keys, going over some of the benefits of doing so and also providing some examples based on our &lt;a href=&quot;https://auth0.com/docs/apiv2&quot;&gt;API v2 scenarios&lt;/a&gt;. This post follows up by explaining an aspect that was not covered before: how to blacklist a JWT API key so it is no longer valid.&lt;/p&gt;

&lt;h1&gt;A real world example&lt;/h1&gt;

&lt;p&gt;Let&#39;s for a second assume that GitHub used JSON Web Tokens as API Keys and one of them was accidentaly published on the web. You would want to make sure an app can no longer access your information by revoking that token:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;//cdn.auth0.com/blog/blacklist_token.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;//cdn.auth0.com/blog/blacklist_token.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Framing the problem&lt;/h1&gt;

&lt;p&gt;Providing support for blacklisting JWTs poses the following questions:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;How are JWTs individually identified?&lt;/li&gt;
&lt;li&gt;Who should be able to revoke JWTs?&lt;/li&gt;
&lt;li&gt;How are tokens revoked?&lt;/li&gt;
&lt;li&gt;How do we avoid adding overhead?&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;This blog post aims to answer the previous questions by leveraging our experience from implementing this feature in our &lt;a href=&quot;https://docs.auth0.com/apiv2&quot;&gt;API v2&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h2&gt;1. How are JWTs individually identified?&lt;/h2&gt;

&lt;p&gt;To revoke a JWT we need to be able to tell one token apart from another one. The JWT spec proposes the &lt;a href=&quot;http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#jtiDef&quot;&gt;&lt;code&gt;jti&lt;/code&gt;&lt;/a&gt; (JWT ID) as a means to identify a token. From the specification:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The jti (JWT ID) claim provides a unique identifier for the JWT. The identifier value MUST be assigned in a manner that ensures that there is a negligible probability that the same value will be accidentally assigned to a different data object; if the application uses multiple issuers, collisions MUST be prevented among values produced by different issuers as well.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As a quick reminder, this is how the claims section of one of our JWT API tokens looks like:
&lt;a href=&quot;//cdn.auth0.com/blog/jwt_blacklist_01.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;//cdn.auth0.com/blog/jwt_blacklist_01.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The tokens accepted by our API use the &lt;code&gt;aud&lt;/code&gt; claim to determine the tenant for which the JWT is valid. If we use the &lt;code&gt;(aud, jti)&lt;/code&gt; pair as the token&#39;s identifier then each tenant is in charge of guaranteeing that there&#39;s no duplication among their tokens.&lt;/p&gt;

&lt;p&gt;Similarly, if a token does not include the &lt;code&gt;jti&lt;/code&gt; claim we do not allow it to be revoked.&lt;/p&gt;

&lt;h2&gt;2. Who should be able to revoke JWTs?&lt;/h2&gt;

&lt;p&gt;If anyone could revoke our API keys then unfortunately they wouldn&#39;t be of much use. We need a way of restricting who can revoke a JWT.&lt;/p&gt;

&lt;p&gt;The way we solved it in our API is by defining a specific scope (permission) that allows blacklisting tokens. If you generate a JWT like the one shown in the next figure you will be able to revoke JWTs:
&lt;a href=&quot;//cdn.auth0.com/blog/jwt_blacklist_02.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;//cdn.auth0.com/blog/jwt_blacklist_02.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Notice the &lt;code&gt;blacklist&lt;/code&gt; action nested inside the &lt;code&gt;scopes&lt;/code&gt; object.&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;3. How are tokens revoked?&lt;/h2&gt;

&lt;p&gt;To blacklist/revoke a token, you need a JWT API key (referred to as &lt;code&gt;JWT_API_KEY&lt;/code&gt;) like the one described in #2. With it you can issue a &lt;code&gt;POST&lt;/code&gt; request to &lt;code&gt;/api/v2/blacklists/tokens&lt;/code&gt; as shown below (new lines added for clarity):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -H &quot;Authorization: Bearer {JWT_API_KEY}&quot;
-X POST
-H &quot;Content-Type: application/json&quot;
-d &#39;{&quot;aud&quot;:&quot;u6nnAxGVjbBd8etXjj554YKGAG5HuVrp&quot;,&quot;jti&quot;:&quot;test-token&quot;}&#39;
https://login.auth0.com/api/v2/blacklists/tokens
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete documentation for the endpoint is &lt;a href=&quot;https://auth0.com/docs/apiv2#!/blacklists/post_tokens&quot;&gt;here&lt;/a&gt; but basically you need to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Send the &lt;code&gt;aud&lt;/code&gt; and &lt;code&gt;jti&lt;/code&gt; claims of the JWT to revoke.&lt;/li&gt;
&lt;li&gt;Send the JWT with the permissions necessary to blacklist tokens in the &lt;strong&gt;Authorization&lt;/strong&gt; header.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;To get the revoked tokens you can issue a &lt;code&gt;GET&lt;/code&gt; to &lt;code&gt;/api/v2/blacklists/tokens&lt;/code&gt;. You can use the &lt;a href=&quot;https://auth0.com/docs/apiv2#!/blacklists/get_tokens&quot;&gt;docs&lt;/a&gt; to figure out the how.&lt;/p&gt;

&lt;h2&gt;4. How do we avoid adding overhead?&lt;/h2&gt;

&lt;p&gt;You might be thinking:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Wasn&#39;t the whole point of using JWTs avoiding a DB query?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, that is a benefit, though harshly the &lt;em&gt;whole point&lt;/em&gt;. There is a caveat though: that question only applies if you have an application with a single issuer, not a multi-tenant system.&lt;/p&gt;

&lt;p&gt;If there is more than one tenant, you don&#39;t want all of them to share the same secret. You still have to perform a database query to map the &lt;code&gt;aud&lt;/code&gt; claim to the required &lt;code&gt;secret&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With that in mind, these are some of the optimizations that you can implement:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Optimization 1&lt;/strong&gt;: The aforementioned operation involves I/O so it can be performed in parallel with our query to verify if a token has been revoked.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Of course, you can also add a caching layer with a reasonable expiration time to avoid the DB trips altogether.&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Optimization 2&lt;/strong&gt;: Skip the expiration check if the &lt;code&gt;jti&lt;/code&gt; claim is not part of the JWT.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Optimization 3&lt;/strong&gt;: To reduce the size of the revoked tokens store you could automatically remove JWTs from it once their &lt;a href=&quot;http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#expDef&quot;&gt;&lt;code&gt;exp&lt;/code&gt;&lt;/a&gt; is reached (assuming there is one).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a name=&quot;impl&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Implementation&lt;/h2&gt;

&lt;p&gt;We have shipped version 1.3.0 of the open source &lt;a href=&quot;https://github.com/auth0/express-jwt&quot;&gt;express-jwt&lt;/a&gt; with support for &lt;a href=&quot;https://github.com/auth0/express-jwt#multi-tenancy&quot;&gt;multi-tenancy&lt;/a&gt; and &lt;a href=&quot;https://github.com/auth0/express-jwt#revoked-tokens&quot;&gt;blacklisted tokens&lt;/a&gt;. We also put together a &lt;a href=&quot;https://github.com/auth0/multitenant-jwt-auth&quot;&gt;sample&lt;/a&gt; that shows everything working together. The sample is based on our &lt;a href=&quot;https://docs.auth0.com/apiv2&quot;&gt;API v2&lt;/a&gt; implementation.&lt;/p&gt;

&lt;p&gt;The following code snippets use show the core sample parts:&lt;/p&gt;

&lt;h3&gt;Securing the endpoint&lt;/h3&gt;

&lt;p&gt;The first thing we have is an API that we would like to protect. The &lt;code&gt;express-jwt&lt;/code&gt; middleware is configured by providing:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;secret&lt;/code&gt; - A function in charge of retrieving the secret.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isRevoked&lt;/code&gt; - A function in charge of checking if a JWT is revoked.&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var expressJwt = require(&#39;express-jwt&#39;);
// to protect /api routes with JWTs
app.use(&#39;/api&#39;, expressJwt({
  secret: secretCallback,
  isRevoked: isRevokedCallback
}));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Handling multi-tenancy&lt;/h3&gt;

&lt;p&gt;The implementation for the &lt;code&gt;secretCallback&lt;/code&gt; function reads the backing data store to retrieve the secret for a tenant.  It caches the secrets using the tenant identifier as the cache key.&lt;/p&gt;

&lt;p&gt;If the data layer provides an encrypted tenant secret, it needs to be decrypted before calling &lt;code&gt;done&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var LRU = require(&#39;lru-cache&#39;);

var secretsCache = LRU({ /* options */ });

var secretCallback = function(req, payload, done){
  var audience = payload.aud;
  var cachedSecret = secretsCache.get(audience);

  if (cachedSecret) { return done(null, cachedSecret); }

  data.getTenantByIdentifier(audience, function(err, tenant){
    if (err) { return done(err); }
    if (!tenant) { return done(new Error(&#39;missing_secret&#39;)); }

    var secret = utilities.decrypt(tenant.secret);
    secretsCache.set(audience, secret);
    done(null, secret);
  });
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Supporting revoked JWTs&lt;/h3&gt;

&lt;p&gt;Similarly, the &lt;code&gt;isRevokedCallback&lt;/code&gt; implementation caches whether a token is revoked or not using the &lt;code&gt;(aud, jti)&lt;/code&gt; pair as the cache key. It also skips the check in case the &lt;code&gt;jti&lt;/code&gt; claim is not present.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var jtiCache = LRU({ /* options */ });

var isRevokedCallback = function(req, payload, done){
  var tokenId = payload.jti;
  if (!tokenId){
    // if it does not have jti it cannot be revoked
    return done(null, false);
  }

  var tokenIdentifier = payload.aud + &#39;:&#39; + payload.jti;
  var blacklisted = jtiCache.get(tokenIdentifier);
  if (typeof blacklisted !== &#39;undefined&#39;) { return done(null, blacklisted); }

  data.getRevokedTokenByIdentifier(tokenIdentifier, function(err, token){
    if (err) { return done(err); }
    blacklisted = !!token;
    jtiCache.set(tokenIdentifier,blacklisted)
    return done(null, blacklisted);
  });
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Most of the aforementioned content applies to blacklisting JWTs in general, not just JWT API keys.&lt;/p&gt;

&lt;p&gt;Hopefully this blog post has provided some useful ideas on how to tackle this problem.&lt;/p&gt;

&lt;p&gt;If you have any comments or questions don&#39;t hesitate to post them!&lt;/p&gt;

&lt;p&gt;You an also get involved in &lt;a href=&quot;https://github.com/auth0/express-jwt&quot;&gt;express-jwt&lt;/a&gt;!&lt;/p&gt;

&lt;iframe src=&quot;https://ghbtns.com/github-btn.html?user=auth0&amp;amp;repo=express-jwt&amp;amp;type=star&amp;amp;count=true&quot; frameborder=&quot;0&quot; scrolling=&quot;0&quot; width=&quot;170px&quot; height=&quot;20px&quot;&gt;&lt;/iframe&gt;

</description>
        </item>
      
    
      
        <item>
          <title>Using Azure Services without a Backend</title>
          <link>https://auth0.com/blog/2015/02/10/using-azure-services-without-a-backend/</link>
          <pubDate>Tue, 10 Feb 2015 09:00:00 -0300</pubDate>
          <author>Nathan Totten</author>
          <avatar>https://www.gravatar.com/avatar/d48b998c2dce49ca309710eba498c562.png?s=60</avatar>
          <guid>https://auth0.com/blog/2015/02/10/using-azure-services-without-a-backend</guid>
          <description>&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;: you can access Azure Storage APIs securely from browsers (i.e. using JavaScript) or native apps, without the need of a backend server. Live demo @ &lt;a href=&quot;http://auth0.github.io/auth0-azure-blob-sample/&quot;&gt;http://auth0.github.io/auth0-azure-blob-sample/&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Today’s modern cloud provides developers with a rich choice of building blocks for creating new and innovative applications faster than ever before. Utilizing Auth0 developers can build applications that are secure and scalable without the need for a traditional backend server. This significantly reduces your time to release as well as the cost of maintenance over the life of your application.&lt;/p&gt;

&lt;p&gt;In this post you will see an example of how you can use Auth0 and the near infinite scale of Azure Blob Storage to build a rich and secure client application without a traditional backend. This example is built entirely in HTML/JavaScript and runs in the browser while still providing secure, authenticated access to resources in Azure Blob Storage.&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;Below you will find a simple diagram showing how this application will work. Notice that the browser app only communicates either with Auth0 or with blob storage directly. We don’t need backend server helping with security – Auth0 does this for us.&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://cloudup.com/cpLqCchdjHP+&quot;&gt;&lt;/div&gt;


&lt;h2&gt;Logging In&lt;/h2&gt;

&lt;p&gt;Authenticating with Auth0 is a breeze. To log the user in we will use the Auth0 Lock widget. After the user clicks throught to login the callback will be returned and we can take the token and profile data and store them in the browser&#39;s local storage. After the data is stored, we redirect the user to the files.html page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;
var lock = new Auth0Lock(window.config.clientId, window.config.domain);

document.getElementById(&#39;btn-login&#39;).addEventListener(&#39;click&#39;, function() {
  lock.show({ popup: true }, function(err, profile, token) {
    if (err) {
      // Error callback
      alert(&#39;There was an error&#39;);
    } else {
      // Success calback

      // Save the JWT token.
      store.set(&#39;azure_sample_id_token&#39;, token);

      // Save the profile
      store.set(&#39;azure_sample_profile&#39;, JSON.stringify(profile));

      location.href = &#39;files.html&#39;;
    }
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Retrieving the Azure Storage SAS Token&lt;/h2&gt;

&lt;p&gt;Auth0 integrates with a variety of identity providers as well as a number of additional services we call addons. We support a variety of addons such as &lt;a href=&quot;https://auth0.com/docs/server-apis/firebase&quot;&gt;Firebase&lt;/a&gt;, &lt;a href=&quot;https://auth0.com/docs/server-apis/salesforce&quot;&gt;Salesforce&lt;/a&gt;, &lt;a href=&quot;https://auth0.com/docs/server-apis/azure-sb&quot;&gt;Azure Service Bus&lt;/a&gt;, and &lt;a href=&quot;https://auth0.com/docs/server-apis/azure-blob-storage&quot;&gt;Azure Storage&lt;/a&gt;. You can use these addons to exchange your traditional user tokens for API specific tokens – in our example, we will use our JWT token issued by Auth0 for a Azure Blob SAS token in order for the browser client to securely read and write to storage.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;auth0.getDelegationToken({
  id_token: current_id_token,
  scope: &quot;openid&quot;,
  api_type: &quot;azure_blob&quot;,
  containerName: id_hash + &quot;my-container-name&quot;
}, function(err, delegationResult) {
  callback(delegationResult.azure_blob_sas);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Rules&lt;/h2&gt;

&lt;p&gt;In addition to simply exchanging tokens we can use a feature in Auth0 called &lt;a href=&quot;https://auth0.com/docs/rules&quot;&gt;Rules&lt;/a&gt; to fully control user access to containers and blobs. Rules are Javascript functions that run on Auth0 in response to various authentication events. You can use rules to completely customize how authentication works inside your application.&lt;/p&gt;

&lt;p&gt;In our example, I am simply limiting each user to a single blob that they own, but you could image that we could build a rich role-based access list for users to provide fine-grained control over storage resources. You can see the code for our rule below. Notice how we are using the Azure Storage SDK inside of the rule to check if containers exist and create new containers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function(user, context, callback) {

  var CLIENT_ID = &quot;your_client_id_here&quot;;

  // Only run this rule for the correct app and for azure_blob delegations
  if (!(context.clientID === CLIENT_ID &amp;amp;&amp;amp;
        context.isDelegation &amp;amp;&amp;amp;
        context.request.body.api_type === &#39;azure_blob&#39;)) {
    return callback(null, user, context);
  }

  var blobName = context.request.body.blobName;
  var containerName = context.request.body.containerName;

  // Get user id hash
  var shasum = crypto.createHash(&#39;sha1&#39;);
  shasum.update(user.user_id);
  var hash = shasum.digest(&#39;hex&#39;);

  // Check to make sure the container belongs to the user
  if (containerName !== hash) {
    return callback(new UnauthorizedError(&#39;Not authorized.&#39;));
  }

  // For blob requests, we are done
  if (blobName) {
    return callback(null, user, context);
  }

  var blobService = azure_storage.createBlobService(
    configuration.AZURE_STORAGE_ACCOUNT_NAME,
    configuration.AZURE_STORAGE_ACCOUNT_KEY);

  // For container list operations, ensure the container exists
  blobService.createContainerIfNotExists(containerName,
  function(error, result, response) {
    if (error) {
      return callback(error);
    }
    return callback(null, user, context);
  });  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;List Blobs in Container&lt;/h2&gt;

&lt;p&gt;Once we have our container’s SAS token, our browser app can make a request directly to Azure Blob storage to list the contents of the blob.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;var url = &#39;https://blobshare.blob.core.windows.net/&#39; + containerName +
  &#39;?&#39; + sasToken + &#39;&amp;amp;restype=container&amp;amp;comp=list&#39;;
$.ajax({
  url: url,
  type: &quot;GET&quot;,
  success: function(data, status) {
    var model = convertResponseToModel(data);
    callback(null, model);
  },
  error: function(xhr, desc, err) {
    callback(err);
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Upload a Blob&lt;/h2&gt;

&lt;p&gt;Because we want to be able to handle large files we are going to upload our file as a block blob. This allows the browser to make multiple requests to upload small chunks of a large file. This way, if one request fails we simply have to retry a small request rather than retry the entire upload. This means our browser app can handle uploads of very large sizes efficiently.&lt;/p&gt;

&lt;p&gt;Once again, we will call our Auth0 delegation endpoint to exchange our auth token for an azure blob sas token. This token will be for a particular blob rather than a container. Because the code for uploading a blob in blocks is quite long I won’t put a snippet here. You can find a great reference on how to do that on &lt;a href=&quot;http://gauravmantri.com/2013/02/16/uploading-large-files-in-windows-azure-blob-storage-using-shared-access-signature-html-and-javascript/&quot;&gt;Gaurav Mantri’s blog&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Resources&lt;/h2&gt;

&lt;p&gt;Now that we have walked through the steps of building a secure client-only application with Azure Storage and Auth0 you can try out the &lt;a href=&quot;http://auth0.github.io/auth0-azure-blob-sample/&quot;&gt;running application&lt;/a&gt; yourself. Additionally, you can find the &lt;a href=&quot;https://github.com/auth0/auth0-azure-blob-sample&quot;&gt;full source&lt;/a&gt; on Github and &lt;a href=&quot;https://auth0.com/docs/server-apis/azure-blob-storage&quot;&gt;additional documentation&lt;/a&gt; about using Auth0 and Blob storage.&lt;/p&gt;

&lt;div class=&quot;try-banner try-code&quot; style=&quot;margin: 0&quot;&gt;
    &lt;a href=&quot;https://github.com/auth0/auth0-azure-blob-sample&quot; target=&quot;_new&quot; class=&quot;btn btn-default btn-lg&quot;&gt;&lt;i class=&quot; icon-1392070209-icon-social-github icon&quot;&gt;&lt;/i&gt;Code&lt;/a&gt;
    &lt;a href=&quot;http://auth0.github.io/auth0-azure-blob-sample/&quot; target=&quot;_new&quot; class=&quot;btn btn-default btn-lg&quot;&gt;&lt;i class=&quot; icon-budicon-698 icon&quot;&gt;&lt;/i&gt;Demo&lt;/a&gt;
&lt;/div&gt;


&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;I hope this post gave you an understanding of some of the awesome things you can do with Auth0 and the modern cloud. Be sure to sign up for your &lt;a href=&quot;https://auth0.com/pricing&quot;&gt;free developer account&lt;/a&gt; and check out our &lt;a href=&quot;https://auth0.com/docs&quot;&gt;quick start guides&lt;/a&gt;. If you have any questions you can reach our entire team on &lt;a href=&quot;http://chat.auth0.com/&quot;&gt;chat.auth0.com&lt;/a&gt; or &lt;a href=&quot;http://twitter.com/auth0&quot;&gt;@Auth0&lt;/a&gt;.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Auth0 Startup Plan</title>
          <link>https://auth0.com/blog/2015/02/06/auth0-startup-plan/</link>
          <pubDate>Fri, 06 Feb 2015 08:00:00 -0300</pubDate>
          <author>Gianpaolo Carraro</author>
          <avatar>https://www.gravatar.com/avatar/aad435650eb4a93583d6aaa19f3a91f4.png?s=60</avatar>
          <guid>https://auth0.com/blog/2015/02/06/auth0-startup-plan</guid>
          <description>&lt;p&gt;Following last month&#39;s &lt;a href=&quot;https://auth0.com/pricing&quot;&gt;new pricing announcement&lt;/a&gt; and new free and full-featured &lt;a href=&quot;https://auth0.com/signup&quot;&gt;developer plan&lt;/a&gt;, today we are adding a &lt;strong&gt;Startup Plan&lt;/strong&gt; to our pricing.&lt;/p&gt;

&lt;h3&gt;Startup Plan&lt;/h3&gt;

&lt;p&gt;The deal is very simple, if you meet the three conditions below:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;less than $1M in Annual Recurring Revenue (ARR)&lt;/li&gt;
&lt;li&gt;less than $2M in raised funding&lt;/li&gt;
&lt;li&gt;less than 2 years old&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;you get unrestricted usage of Auth0 for 1 year for $99 per month.&lt;/p&gt;

&lt;p&gt;It&#39;s that simple.&lt;/p&gt;

&lt;p&gt;Email &lt;a href=&quot;mailto:startup@auth0.com&quot;&gt;startup@auth0.com&lt;/a&gt; for requesting your Startup plan.&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
